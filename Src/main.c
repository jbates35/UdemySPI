/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#define FAST 100000
#define MEDIUM 300000
#define SLOW 1000000
#define WAIT(CNT)                                                              \
  do {                                                                         \
    for (int def_i = 0; def_i < CNT; def_i++)                                  \
      ;                                                                        \
  } while (0)

/******* PINS *********/
#define LED_GREEN_PORT GPIOB
#define LED_GREEN_PIN 0
#define LED_YELLOW_PORT GPIOE
#define LED_YELLOW_PIN 1
#define LED_RED_PORT GPIOB
#define LED_RED_PIN 14

#define USER_PBUTTON_PORT GPIOC
#define USER_PBUTTON_PIN 13

/********* SPI ********/

#define SPI1_GPIO_PORT GPIOA
#define SPI1_CLOCK_PIN 5
#define SPI1_NSS_PIN 4
#define SPI1_MISO_PIN 6
#define SPI1_MOSI_PIN 7
#define SPI1_ALT_FN 5

#define SPI2_GPIO_PORT GPIOB
#define SPI2_CLOCK_PIN 13
#define SPI2_NSS_PIN 12
#define SPI2_MISO_PIN 14
#define SPI2_MOSI_PIN 15
#define SPI2_ALT_FN 5

/* SPI3 uses multiple ports generally */

#define SPI4_GPIO_PORT GPIOE
#define SPI4_CLOCK_PIN 2
#define SPI4_NSS_PIN 4
#define SPI4_MISO_PIN 5
#define SPI4_MOSI_PIN 6
#define SPI4_ALT_FN 5

#define SPI5_GPIO_PORT GPIOF
#define SPI5_CLOCK_PIN 7
#define SPI5_NSS_PIN 6
#define SPI5_MISO_PIN 8
#define SPI5_MOSI_PIN 9
#define SPI5_ALT_FN 5

#define SPI6_GPIO_PORT GPIOG
#define SPI6_CLOCK_PIN 13
#define SPI6_NSS_PIN 8
#define SPI6_MISO_PIN 12
#define SPI6_MOSI_PIN 14
#define SPI6_ALT_FN 5

/*********** END SPI ********/

/********* TIMERS **********/

#define TIMER_16_GPIO_PORT GPIOF
#define TIMER_16_CH1_PIN 6
#define TIMER_16_CH1N_PIN 8
#define TIMER_16_ALT_FN 1

#define TIMER_17_GPIO_PORT GPIOF
#define TIMER_17_CH1_PIN 7
#define TIMER_17_CH1N_PIN 9
#define TIMER_17_ALT_FN 1

/******* END TIMERS ********/

/******* START ANALOG PINS *********/

#define ANALOG_1_CLK() GPIOF_PCLK_EN()
#define ANALOG_1_ADDR GPIOF
#define ANALOG_1_PIN 5
#define ANALOG_1_CH 4

#define ANALOG_2_CLK() GPIOF_PCLK_EN()
#define ANALOG_2_ADDR GPIOF
#define ANALOG_2_PIN 3
#define ANALOG_2_CH 5

/******* END ANALOG PINS *********/

#include <stdint.h>
#include <string.h>

#include "stm32h723xx.h"
#include "stm32h723xx_gpio.h"
#include "stm32h723xx_spi.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning                                                                       \
    "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

void basic_gpio_init(void);

int main(void) {

  basic_gpio_init();

  GPIO_Handle_t gpio_handle;
  GPIO_RegDef_t **addr = &gpio_handle.p_GPIO_x;
  GPIO_PinConfig_t *cfg = &gpio_handle.GPIO_pin_config;

  ANALOG_1_CLK();
  *addr = ANALOG_1_ADDR;
  cfg->GPIO_pin_number = ANALOG_1_PIN;
  cfg->GPIO_pin_mode = GPIO_MODE_ANALOG;
  cfg->GPIO_pin_speed = GPIO_SPEED_HIGH;
  cfg->GPIO_pin_out_type = GPIO_OP_TYPE_PUSHPULL;
  cfg->GPIO_pin_pupd_control = GPIO_PUPDR_NONE;
  cfg->GPIO_pin_alt_func_mode = 0;
  GPIO_init(&gpio_handle);

  ANALOG_2_CLK();
  *addr = ANALOG_2_ADDR;
  cfg->GPIO_pin_number = ANALOG_2_PIN;
  cfg->GPIO_pin_mode = GPIO_MODE_ANALOG;
  cfg->GPIO_pin_speed = GPIO_SPEED_HIGH;
  cfg->GPIO_pin_out_type = GPIO_OP_TYPE_PUSHPULL;
  cfg->GPIO_pin_pupd_control = GPIO_PUPDR_NONE;
  cfg->GPIO_pin_alt_func_mode = 0;
  GPIO_init(&gpio_handle);

  // Set the ADC clock
  ADC3_PCLK_EN();
  RCC->D3AMR |= (1 << 24);

  // Disable ADC to start
  // ADC3->CR |= (1 << ADC_CR_ADDIS);

  // Exit deep powerdown state
  ADC3->CR &= ~(1 << ADC_CR_DEEPPWD);

  /*Then, it is mandatory to enable the ADC internal voltage regulator by
setting the bit ADVREGEN = 1 into ADC_CR register. The software must wait for
the startup time of the ADC voltage regulator (TADCVREG_STUP) before laun*/
  ADC3->CR |= (1 << ADC_CR_ADVREGEN);
  WAIT(SLOW);

  // Set ADC in continuous mode
  // ADC3->CFGR |= (1 << ADC_CFGR_CONT);

  // Set Data resolution to 10 bit (0 -> 1024)
  ADC3->CFGR &= ~(0x3 << ADC_CFGR_RES);
  ADC3->CFGR |= (0x1 << ADC_CFGR_RES);

  // Enable only two channels in a sequence (I think?)
  ADC3->SQR1 &= ~(0xF << ADC_SQR1_L);
  ADC3->SQR1 |= (0x0 << ADC_SQR1_L);

  // Set channel 1's ... channel
  ADC3->SQR1 &= ~(0xF << ADC_SQR1_SQ1);
  ADC3->SQR1 |= (0x4 << ADC_SQR1_SQ1);

  // Set sample time for channel 1
  ADC3->SMPR1 &= ~(0x7 << ADC_SMPR1_SMP0);
  ADC3->SMPR1 |= (0x7 << ADC_SMPR1_SMP0);

  // Set channel 2's ... channel
  ADC3->SQR1 &= ~(0xF << ADC_SQR1_SQ2);
  ADC3->SQR1 |= (0x5 << ADC_SQR1_SQ2);

  // Set sample time for channel 1
  ADC3->SMPR1 &= ~(0x7 << ADC_SMPR1_SMP1);
  ADC3->SMPR1 |= (0x7 << ADC_SMPR1_SMP1);

  // Need to set in non differential mode I think
  ADC3->DIFSEL = 0;

  // 1. Clear the ADRDY bit in the ADC_ISR register by writing ‘1’.
  // ADC3->ISR |= (1 << ADC_ISR_ADRDY);

  // 2.Set ADEN = 1.
  // ADC3->CR &= ~(1 << ADC_CR_ADDIS);
  ADC3->CR |= (1 << ADC_CR_ADEN);

  // 3.Wait until ADRDY = 1 (ADRDY is set after the ADC startup time). This can
  // be done using the associated interrupt (setting ADRDYIE = 1).
  ADC3->IER |= (1 << ADC_IER_ADRDY_IE);

  // 4.Clear the ADRDY bit in the ADC_ISR register by writing ‘1’ (optional).
  // ADEN bit cannot be set when ADCAL is set and during four ADC clock cycle
  // Enable the ADC peripheral
  // ADC3->ISR |= (1 << ADC_ISR_ADRDY);

  /** LOOK INTO DMA FOR ACCESSING CONVERTED DATA MORE EASILY **/

  /* Loop forever */
  for (;;) {
    // Wait for ADC to be ready
    // while (!(ADC3->ISR & (1 << ADC_ISR_ADRDY)))
    ;

    // Start conversion
    ADC3->CR |= (1 << ADC_CR_ADSTART);

    // Wait for end of conversion
    while (!(ADC3->ISR & (1 << ADC_ISR_EOC)))
      ;

    // Access data register
    uint32_t data[2];

    data[0] = ADC3->DR;

    int asdf = 0;

    data[1] = ADC3->DR;

    asdf = 1;

    while (!(ADC3->ISR & (1 << ADC_ISR_ADRDY)))
      ;

    asdf = 1;
    // GPIO_toggle_output_pin(LED_GREEN_PORT, LED_GREEN_PIN);
    WAIT(FAST);
  }
}

void basic_gpio_init(void) {
  SYSCFG_PCLK_EN();

  // User button PC13
  // LED is on PB0
  GPIO_peri_clock_control(USER_PBUTTON_PORT, ENABLE);
  GPIO_peri_clock_control(LED_GREEN_PORT, ENABLE);

  // Create GPIO handler and assign shortcuts for easier access
  GPIO_Handle_t gpio_handle;
  GPIO_RegDef_t **addr = &gpio_handle.p_GPIO_x;
  GPIO_PinConfig_t *cfg = &gpio_handle.GPIO_pin_config;

  // User button PC13
  *addr = USER_PBUTTON_PORT;
  cfg->GPIO_pin_number = USER_PBUTTON_PIN;
  cfg->GPIO_pin_mode = GPIO_MODE_IT_FT;
  cfg->GPIO_pin_speed = GPIO_SPEED_LOW;
  cfg->GPIO_pin_pupd_control = GPIO_PUPDR_PULLDOWN;
  cfg->GPIO_pin_out_type = GPIO_OP_TYPE_PUSHPULL;
  cfg->GPIO_pin_alt_func_mode = 0;
  GPIO_init(&gpio_handle);
  GPIO_irq_interrupt_config(IRQ_NO_EXTI15_10, ENABLE);
  // GPIO_irq_priority_config(IRQ_NO_EXTI15_10, USER_PBUTTON_PIN);

  // LED PB0
  *addr = LED_GREEN_PORT;
  cfg->GPIO_pin_number = LED_GREEN_PIN;
  cfg->GPIO_pin_mode = GPIO_MODE_OUT;
  cfg->GPIO_pin_speed = GPIO_SPEED_LOW;
  cfg->GPIO_pin_pupd_control = GPIO_PUPDR_NONE;
  cfg->GPIO_pin_out_type = GPIO_OP_TYPE_PUSHPULL;
  cfg->GPIO_pin_alt_func_mode = 0;
  GPIO_init(&gpio_handle);

  int asdf2 = 0;
  asdf2 = 44;
}

void TIM16_IRQHandler(void) {
  // Clear Timer16 interrupt
  TIM16->SR &= ~(1 << TIM_SR_CC1IF);
}

void EXTI15_10_IRQHandler(void) {

  if (GPIO_irq_handling(USER_PBUTTON_PIN))
    GPIO_toggle_output_pin(LED_GREEN_PORT, LED_GREEN_PIN);
}
